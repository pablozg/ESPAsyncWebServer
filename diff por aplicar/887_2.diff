diff --git a/src/AsyncWebSynchronization.h b/src/AsyncWebSynchronization.h
index f36c52dc..02ad2dc6 100644
--- a/src/AsyncWebSynchronization.h
+++ b/src/AsyncWebSynchronization.h
@@ -7,6 +7,38 @@
 
 #ifdef ESP32
 
+// This is the ESP32 version of the Sync Lock, using the FreeRTOS Semaphore
+// Modified 'AsyncWebLock' to just only use mutex since pxCurrentTCB is not
+// always available. According to example by Arjan Filius, changed name,
+// added unimplemented version for ESP8266
+class AsyncPlainLock
+{
+private:
+  SemaphoreHandle_t _lock;
+
+public:
+  AsyncPlainLock() {
+    _lock = xSemaphoreCreateBinary();
+    // In this fails, the system is likely that much out of memory that
+    // we should abort anyways. If assertions are disabled, nothing is lost..
+    assert(_lock);
+    xSemaphoreGive(_lock);
+  }
+
+  ~AsyncPlainLock() {
+    vSemaphoreDelete(_lock);
+  }
+
+  bool lock() const {
+      xSemaphoreTake(_lock, portMAX_DELAY);
+      return true;
+  }
+
+  void unlock() const {
+    xSemaphoreGive(_lock);
+  }
+};
+
 // This is the ESP32 version of the Sync Lock, using the FreeRTOS Semaphore
 class AsyncWebLock
 {
@@ -17,6 +49,9 @@ class AsyncWebLock
 public:
   AsyncWebLock() {
     _lock = xSemaphoreCreateBinary();
+    // In this fails, the system is likely that much out of memory that
+    // we should abort anyways. If assertions are disabled, nothing is lost..
+    assert(_lock);
     _lockedBy = NULL;
     xSemaphoreGive(_lock);
   }
@@ -61,6 +96,10 @@ class AsyncWebLock
   void unlock() const {
   }
 };
+
+// Same for AsyncPlainLock, for ESP8266 this is just the unimplemented version above.
+using AsyncPlainLock = AsyncWebLock;
+
 #endif
 
 class AsyncWebLockGuard
@@ -84,4 +123,4 @@ class AsyncWebLockGuard
   }
 };
 
-#endif // ASYNCWEBSYNCHRONIZATION_H_
\ No newline at end of file
+#endif // ASYNCWEBSYNCHRONIZATION_H_
